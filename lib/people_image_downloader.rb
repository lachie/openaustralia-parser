require 'mini_magick'
require 'mechanize_proxy'

require 'configuration'
require 'name'
require 'hpricot'

require 'uri'

# TODO: Rename class
class PeopleImageDownloader
  @@SMALL_THUMBNAIL_WIDTH = 44
  @@SMALL_THUMBNAIL_HEIGHT = 59

  def initialize
    # Required to workaround long viewstates generated by .NET (whatever that means)
    # See http://code.whytheluckystiff.net/hpricot/ticket/13
    Hpricot.buffer_size = 262144

    @conf  = Configuration.new
    @agent = MechanizeProxy.new
    @agent.cache_subdirectory = "member_images"
  end

  def download(people, small_image_dir, large_image_dir)
    each_person_bio_page(people) do |page|
      download_page(page, people, small_image_dir, large_image_dir)
    end
  end

  def download_page(page, people, small_image_dir, large_image_dir)
    name, birthday, image = extract_name(page), extract_birthday(page), extract_image(page)

    if !name && !image
      puts "WARNING: Couldn't find name or photo on page"

    elsif ! name
      puts "WARNING: Couldn't find name on page"

    elsif ! image
      puts "WARNING: Can't find photo on page for #{name.full_name}"

    else
      
      # Small HACK - removing title of name
      name = Name.new(:first => name.first, :middle => name.middle, :last => name.last, :post_title => name.post_title)

      if person = people.find_person_by_name_and_birthday(name, birthday)
        # NOTE minimagick is resizing the same image in place, based on the blob... 
        # this works ok if we do large then small, but its a big caveat!
        #
        large_img = File.join(large_image_dir, "#{person.id_count}.jpg")
        image.resize("%dx%d" % [@@SMALL_THUMBNAIL_WIDTH * 2, @@SMALL_THUMBNAIL_HEIGHT * 2]).write(large_img)

        small_img = File.join( small_image_dir, "#{person.id_count}.jpg")
        image.resize("%dx%d" % [@@SMALL_THUMBNAIL_WIDTH, @@SMALL_THUMBNAIL_HEIGHT]    ).write(small_img)
      else
        puts "WARNING: Skipping photo for #{name.full_name} because they don't exist in the list of people"
      end
    end
  end

  # Returns nil if page can't be found
  def biography_page_for_person_with_name(text)
    url = "http://parlinfo.aph.gov.au/parlInfo/search/display/display.w3p;query=Dataset:allmps%20#{URI.escape(text)}"
    page = @agent.get(url)

    # Check if the returned page is a valid one. If not just ignore it
    tag1 = page.at('div#content')
    tag2 = page.at('div#content div.error')


    unless (tag2 && tag2.inner_text =~ /There was an unexpected error while processing your request./) ||
      (tag1 && tag1.inner_html =~ /No results found/)
      page
    end
  end

  # Each person can be looked up with a query like this:
  # http://parlinfo.aph.gov.au/parlInfo/search/display/display.w3p;query=Dataset:allmps%20John%20Smith
  def biography_page_for_person(person)
    # Check each variant of a person's name and return the biography page for the first one that exists
    person.name_variants.each do |name|
      if page = biography_page_for_person_with_name(name)
        return page
      end
    end
  end
  
  def each_person_bio_page(people)
    # Sort all the people by last name
    sorted_people = people.sort {|a, b| a.name.last <=> b.name.last}

    sorted_people.each do |person|
      if page = biography_page_for_person(person)
        yield page
      end
    end
  end

  def extract_name(page)
    title = strip_tags(extract_metadata_tags(page)["Title"])

    if title =~ /^Biography for (.*)$/
      Name.last_title_first($~[1])
    else
      throw "Unexpected form for title of biography page: #{title}"
    end
  end
  
  # Returns an array of values for the metadata
  def raw_metadata(page)
    labels = page.search('label.mdLabel')
    values = page.search('div.mdValue')

    throw "Number of values do not match number of labels" if labels.size != values.size

    metadata = {}

    labels.each_with_index do |label,index|
      label = label.inner_text
      value = values[index].search('p.mdItem').map {|e| e.inner_html.gsub(/&nbsp;/, '')}
      metadata[label] = value unless value.empty?
    end

    metadata
  end
  
  # Extract a hash of all the metadata tags and values
  def extract_metadata_tags(page)
    r = raw_metadata(page)
    r.each_pair {|key, value| r[key] = value.join(', ')}
    r
  end

  def strip_tags(doc)
    str = doc.to_s
    str.gsub(/<\/?[^>]*>/, "")
  end
  
  def extract_birthday(page)
    #Try to scrape the member's birthday.
    #Here's an example of what we are looking for:
    #<H2>Personal</H2>
    #<P>Born 9.1.42
    # or
    #<H2>Personal</H2><P>
    #<P>Born 4.11.1957

    born = page.parser.to_s.match("Born\\s\\d\\d?\\.\\d\\d?\\.\\d\\d(\\d\\d)?")
    if(born and born.to_s.size > 0)
      born_text = born.to_s[5..-1]
      born_text = born_text.insert(-3, "19") if born_text.match("\\.\\d\\d$") # change 9.1.42 to 9.1.1942
      birthday = Date.strptime(born_text, "%d.%m.%Y")
    else
      birthday = nil
    end
    birthday
  end
  
  def extract_image(page)
    img_tag = page.search('div.box').search("img").first
    if img_tag
      relative_image_url = img_tag.attributes['src']
      #begin
        #puts "About to lookup image #{relative_image_url}..."
        res = @agent.get(relative_image_url)
        MiniMagick::Image.from_blob(res.body)
      #rescue RuntimeError, Magick::ImageMagickError, WWW::Mechanize::ResponseCodeError
      #  return nil
      #end
    end
  end
end
